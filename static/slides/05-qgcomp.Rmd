---
title: "Quantile G-Computation"
author: "Bradley Bowen"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    css: "./tutorials.css"
    toc: true
    toc_float: true
---

## qgcomp Package

Weighted Quantile Sum Regression (WQS) allows researchers to understand the effects of highly correlated components. In a previous tutorial, we used the `gWQS` package to implement modeling fitting, inference, and diagnostics. An additional method used to employ Weighted Quantile Sum Regression is the `qgcomp` package. This method relaxes the "unidirectional relationship" assumption of WQS, here the components do not have to contribute in the same direction. Additionally, `qgcomp` has greater computation efficiency and it allows more flexibility on modeling non-linear relationship.

In this tutorial, we will demonstrate how the `qgcomp` can provide additional flexibility when analyzing chemical mixtures. Specifically, we will explore applications for (1) linear model (2) linear model with covariates (3) non-linear model (4) missing data, limits of detection, and multiple imputation

## Libraries

For this tutorial, we will be using similar packages to the previous tutorials. Note that in addition to `qgcomp`, we will also use the `splines` package for [Non-Linear Models] later in the tutorial.

```{r}
#| message: false

#| install.packages("gWQS")
#| install.packages("qgcomp")
#| install.packages("corrplot")
#| install.packages("ggcorrplot")
#| install.packages("splines")
#| 
library(gWQS)
library(tidyverse)
library(tidymodels)
library(dplyr)
library(ggcorrplot)
library(splines)
library(corrplot)
```

## Exploratory Data Analysis

For this analysis, we will be using the `nhanes` dataset, which can be loaded into R studio.

```{r}
load(file='nhanes1518.rda')
head(nhanes1518)
```
Consistent with prior tutorials, we hope to study the impacts of specific chemical exposures (Phalates and Phytoestrogen) on log(BMI), for participants over 18. The `nhanes` data can be normalized through this method.

```{r}
nhanes <- nhanes1518 |>
    filter(RIDAGEYR >= 18)|>
    mutate(BMXBMIlog = log(BMXBMI),
          RIDAGEYR = RIDAGEYR - 18)|>
    select(BMXBMI, BMXBMIlog, URXMHBP, URXMOH, URXMHP, URXMHH, URXMCOH, URXMHNC, URXMHH, URXECP, URXHIBP, URXMIB, RIDAGEYR)

nhanes <- drop_na(nhanes)

nhanes
```

## qgcomp Model

The`qgcomp`package shares similarities to `gWQS`, but there are several key distinctions. Primarily, an essential assumption from `gWQS` was that all predictor variables must contribute to the same direction. However, `qgcomp` can fit a model regardless of the contributing direction of the variables. Similarly, `qgcomp` uses quantiles by default (0,1,2,3) and transforms the data.

Similar to `gWQS`, `qgcomp` can be applied to a standard linear regression model:

$$\mathbb{E}(Y^{\mathbf{X}_q} | \mathbf{Z,\psi,\eta}) = g(\psi_0 + \psi_1 S_q + \mathbf{\eta Z})$$
In the model above, $\psi_0$ represents the intercept while $S_q$ is the combined effect of the exposures (predictor variables). $\mathbf{\eta Z$ is the error term, demonstrating the uncertainty in the model. Lastly, $\mathbf{X}_q$ is the transformation of of the X variable that has been sorted into quantiles.

## Model Fitting

`qgcomp` has similar arguments to the `gWQS` package; however, there are several formatting differences:

`q` - specifies the number of quantiles to be used `B` - number of bootstrap samples `degree` - the number of parameters estimated in the model fitting process

## Linear Model

```{r}
library("qgcomp")
```

Predicting log(BMI) using the same chemical exposures (Phalates and Phytoestrogen) from the `gWQS` tutorial, a similar result can be accomplished in a shorter timeframe.

```{r}
chem_names_new <- c('URXMHBP', 'URXMOH',  'URXMHP',  'URXMHH',  'URXMCOH', 'URXMHNC', 'URXECP', 'URXHIBP', 'URXMIB')
system.time(qc.fit <- qgcomp.noboot(BMXBMIlog~.,dat=nhanes[,c(chem_names_new, 'BMXBMIlog')], family=gaussian()))

system.time(results <- gwqs(BMXBMIlog ~ wqs, mix_name = chem_names_new, data = nhanes, 
                q = 10, validation = 0.6, b = 1, b1_pos = TRUE, 
                b1_constr = FALSE, family = "gaussian", seed=1))
```

The WQS model resulted in a greater elapsed time (36.9 seconds) compared to the qgcomp model (0.277 seconds).

The output of the linear model is demonstrated below:

```{r}
qc.fit
```

Similar to gWQS, a regression model output is provided which follows the same interpretation as above. The coefficients, standard errors, confidence intervals, t-statistics, and p-values are provided.

The Regression output:

$$ \widehat{log(\text{BMXBMI})} = 3.319 + 0.019 \times (WQS) $$ As demonstrated above, the standard linear output is very similar to that of the WQS model. Although the coefficients vary slightly (WQS slope: 0.015, WQS intercept: 3.318), both methods produce a similar result.

To confirm that this model is appropriate, we can visualize the weights and the residuals:

```{r}
plot(qc.fit)

```

```{r}
plot(qc.fit$fit, which=1)
```

Examining the residual plot, the datum appear to be fairly evenly spread about the axis. However, there appears to be a cluster of points centered between 3.3 and 3.5. Despite this, the there are generally no major concerns with the residuals. 

Another useful application of `qgcomp` is to find the effect of mixtures on binary variables (variables that can be represented by 1's "Yes" or 0's "No"). In this example, we want to predict whether a participant is above the average BMI based on the chemical mixtures used in the previous example. We can create a binary variable corresponding for a participant that is greater than the average BMI (represented with 1) or below the average BMI (represented with 0).

The following code can automate this process.

```{r}
nhanes <- nhanes |>
      mutate(BMXBMIOVER = ifelse(BMXBMI >= 24.9,1,0))
```

Now that the BMIOVER variable is now in terms of 1's and 0's, we can use `qgcomp` to predict if a participant is over the average BMI using the chemical mixtures.

```{r}
chem_names_new <- c('URXMHBP', 'URXMOH',  'URXMHP',  'URXMHH',  'URXMCOH', 'URXMHNC', 'URXECP', 'URXHIBP', 'URXMIB')
qc.fit2 <- qgcomp.noboot(BMXBMIOVER~.,dat=nhanes[,c(chem_names_new, 'BMXBMIOVER')], family=binomial())

qc.fit2
```

We can interpret both the intercept intercepts and coefficient for the models:

As the quantile sum increases by 1, an individual's BMI being over vs. under the national average decreases by approximately 1.26%.

When the quantile sum is approximately zero, the probability of an individual being over vs. under the national average is approximately 2.16. 

A similarity to Weighted Quantile Sum Regression is the ability to adjust for covariates. As demonstrated in the WQS tutorial, we are interested if our model does a better job of predicting BMI while adjusting for the age variable, RIDAGEYR.

```{r}

covars = c('RIDAGEYR')

qcboot.fit5 <- qgcomp.noboot(BMXBMIlog~.,dat=nhanes[,c(chem_names_new,covars, 'BMXBMIlog')], family=gaussian())

qcboot.fit5
```

In order to determine if the model with the age covariate is better than our original model, we can once again compare the AIC:

```{r}
#AIC For First Model
AIC(qc.fit)
#AIC For Covariate Model
AIC(qcboot.fit5)

```

The second model, with age added as a covariate, has a lower AIC. This allows us to conclude that log(BMI) can be better predicted with age included in the model.


Unlike WQS, the qgccomp package allows the variables to contribute in different directions, as demonstrated with the "weights." Instead of unidirectional relationships, a weight is assigned to the individual chemical exposure corresponding to "the proportion of the overall effect when all of the exposures have effects in the same direction" (CRAN). The weights are shown in the figure below:

```{r}
plot(qcboot.fit5)
```

An interesting output of the `qgcomp` model is the sum of the positive and negative coefficients. In application, this appears to equate to a "partial effect," the impact of a chemical with a positive/negative coefficient. However, it cannot be interpreted as a "true partial effect" due to the fact that the sum of the coefficients depends on the model results/fit.

In order to estimate the partial effects without the issues discussed above, a sample splitting procedure can be used by creating training and validation dataset. More information on how to complete this procedure can be found on the CRAN website <https://cran.r-project.org/web/packages/qgcomp/vignettes/qgcomp-vignette.html>.

## Non-Linear Models

However, unlike `gWQS`, `qgcomp` can deal with non-linearity, where the relationship between the response and predictors do not follow a linear pattern. In the following example, the same predictor variables are transformed and squared in order to reflect a non-linear relationship.

```{r}
qcboot.fit5 <- qgcomp(BMXBMIlog~. + .^2,
                         expnms=chem_names_new,
                         nhanes[,c(chem_names_new, 'BMXBMIlog')], family=gaussian(), q=4, degree=2, B=5, seed=125)
```

```{r}
qcboot.fit5
```

Although this model provides a result, it is difficult when there are numerous chemical mixtures as predictors. However, we can narrow down the variables by examining a correlation matrix. It is possible that exposures that are highly correlated with each other may have an underlying similarities, "a common environmental source or set of behaviors."

By viewing the following correlation matrix of the urine samples:

```{r}
nhanescor <- nhanes|> select(BMXBMIlog, URXMHBP, URXMOH, URXMHP, URXMHH, URXMCOH, URXMHNC, URXMHH, URXECP, URXHIBP, URXMIB, RIDAGEYR)

cor_hanes <- cor(nhanescor)

corrplot(cor_hanes, order = 'hclust', addrect = 4)
```

From the above plot, we can see that several variables are highly correlated with each other. For this example, we will use the URXMHNC, URXMCOH, and URXMOH variables.

To find the best fit for the data, three separate models will be used: a standard linear model, a non-linear model, and an interaction model. To compute the models, a new package called Splines will be used. Since we will be using non-linear models, Splines uses a "piecewise" polynomial regression method to for estimation (as shown below):

![Splines Example](1200px-Parametic_Cubic_Spline.svg.png){width="317"}
For more information about the Splines package, please visit <https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-019-0666-3>.

```{r, cache=TRUE}
correlated_chems <- c('URXMHNC', 'URXMCOH',  'URXMOH')

qc.fit6lin <- qgcomp.glm.boot(BMXBMIlog ~ URXMHNC + URXMCOH  + URXMOH + URXMHP + URXMHBP + URXMHP + URXMHH + URXMHH + URXECP + URXHIBP + URXMIB,
                         expnms=correlated_chems,
                         nhanes, family=gaussian(), q=4, B=5)

qc.fit6nonlin <- qgcomp.glm.boot(BMXBMIlog ~ bs(URXMHNC) + bs(URXMCOH) + bs(URXMOH)+ URXMHP + URXMHBP + URXMHP + URXMHH + URXMHH + URXECP + URXHIBP + URXMIB,
                         expnms=correlated_chems,
                         nhanes, family=gaussian(), q=4, B=5, degree=1)
```

```{r}
qc.fit6lin

pl.fit6lin <- plot(qc.fit6lin, suppressprint = TRUE, pointwiseref = 4)
pl.fit6lin + coord_cartesian(ylim=c(-0.75, .75))
```

```{r}
qc.fit6nonlin
pl.fit6nonlin <- plot(qc.fit6nonlin, suppressprint = TRUE, pointwiseref = 4)
pl.fit6nonlin + coord_cartesian(ylim=c(-0.75, .75)) + 
  ggtitle("Non-linear fit: mixture of iron, lead, and cadmium")
```


## Missing Data, Limits of Detection, and Multiple Imputation

It is often that datum may include missing entries, possibly causing concern for conclusions. Similar to linear regression, there are methods to handle these situations.

Primarily, a complete case analysis is often used for creating models. This means that all data entries have complete information, those with NA's are removed entirely. Unlike other regression packages, qgcomp package requires the researcher to make their own dataset with the function complete.cases.

Additionally, missing data can become problematic when chemical exposures fall below the limit of detection. One method to correct this issue is to use very small values for the missing entries. As a general rule for qgcomp, if the proportion of the number of entries (below the limit of detection) are less than 1/(q), where q is the number of quantiles used, small values may be utilized.

Lastly, missing data can be handled by a method called multiple imputation. This procedure replaces entries without data with "specific values" so that all participants can be included in the study (those with missing data do not have to be excluded entirely). Similar to above, a new dataset can be created using multiple imputation. Suggested packages include mice, with the function mice.impute.leftcenslognorm for best interface results with qgcomp.

## Miscellaneous

An additional feature of `qgcomp` is the use of time-to-event data analysis. This method helps predict whether and when an event happened. Standard linear models are unable to compute this metric, but it can be helpful in medical applications.

The `qgcomp` package also has the capabilities to compute models despite the data having covariance among observations (the error term is not independent for individual observations). To compensate for this issue, cluster-based sampling and bootstrapping can be used through `qgcomp.glm.boot`.

To read more about how to complete these steps and for additional applications of the qqgcomp model, visit the following website: <https://cran.r-project.org/web/packages/qgcomp/vignettes/qgcomp-vignette.html>

## References

<https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-019-0666-3>
<https://cran.r-project.org/web/packages/qgcomp/vignettes/qgcomp-vignette.html>
